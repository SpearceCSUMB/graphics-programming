<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Raytracer</title>
</head>
<body>
<canvas id='my-canvas'><canvas>

<script src='math/vector3.js'></script>
<script src='math/ray.js'></script>
<script src='math/sphere.js'></script>
<script src='math/plane.js'></script>
<script>

// Canvas setup, don't need to anything in this section ************************
// Get a reference to the javascript object associated with the canvas
var canvas = document.getElementById('my-canvas');

// The canvas dimension we will set
var pixelsAcross = 256;  // pixels across
var pixelsDown = 256; // pixels down

// Set dimensions and pixel scale (generally you can ignore pixelScale, it won't affect your maths)
var pixelScale = 3;
canvas.width = pixelsAcross;
canvas.height = pixelsDown;
canvas.style.cssText = 'width:' + (pixelsAcross * pixelScale) + 'px;height:' + (pixelsDown * pixelScale) + 'px';

// Get the context from the canvas (in this case we just want 2d)
var canvasContext = canvas.getContext('2d');

// Get an array representing all of the pixels
// Arranged left to right, top to bottom
var imageData = canvasContext.getImageData(0, 0, pixelsAcross, pixelsDown);
// end canvas setup section *****************************************************


// Raytracer scene data setup
var fov = 45;   // if this changes, your code should still work
var fovRadians = fov * Math.PI / 180; // todo -> convert degrees to radians

var pixelWidth = 2 / pixelsAcross; // todo -> what's the size of a pixel from left to right? (-1 to 145)
var pixelHalfWidth = pixelWidth / 2; // todo -> half of the pixel width

// How far away (scalar) the eye is from the image plane (see MV3202 guide for more info)
// = todo -> hint: related to tangent and field of view (see slides)
var eyeDistance = 1 / Math.tan(fovRadians / 2); // 1 is half the width (from -1 to 1)
// -----------
// |         /
// |        /
// |       /
// | 45/2 /      <---- half angle
// |     /
// |    /
// |   /
// |  /
// | /

// important vectors
var eyeCoordinate = new Vector3(0, 0, eyeDistance); // all of your rays will use this

// Define the scene objects here ------------------
var lightPosition = new Vector3(1,0,0);
// These are 3d definitions that match all of the math we did in class
// They also provide a "raycast" function that you can pass a ray to
// in order to find intersection between the ray and the object

var sphere = new Sphere(new Vector3(0,0,0),0.25);

//Floor
var floorPlane = new Plane(new Vector3(0,1,0), new Vector3(0,-0.25,0));
var leftWall = new Plane(new Vector3(1,0,0), new Vector3(-1,0,0));
var rightWall = new Plane(new Vector3(-1,0,0), new Vector3(1,0,0));
var topPlane = new Plane(new Vector3(0,-1,0), new Vector3(0,0.75,0));
var backWall = new Plane(new Vector3(0,0,1), new Vector3(0,0,-1.5));

var scene = [floorPlane,leftWall,rightWall,topPlane,backWall,sphere];
// end of raytracer setup ******************************************************

// -----------------------------------------------------------------------------
// return a ray that goes from the eye point through the pixel at index (xPixelIndex, yPixelIndex)
function generateRayForPixel(xPixelIndex, yPixelIndex) {
    var pixelX = -1 + pixelHalfWidth + pixelWidth * xPixelIndex;
    var pixelY = 1 - pixelHalfWidth - pixelWidth * yPixelIndex;
    var pixelCoordinate = new Vector3(pixelX, pixelY, 0);

    var direction = pixelCoordinate.minus(eyeCoordinate); // = vector from the eye to the pixel

    // Creates a ray from the eye toward the pixelCoordinate
    var pixelRay = new Ray(eyeCoordinate,direction);
    return pixelRay;
}

// -----------------------------------------------------------------------------
function setPixelColor(xPixelIndex, yPixelIndex, shadeOfGray /*[0,1]*/) {
    var index = (yPixelIndex * pixelsAcross + xPixelIndex) * 4; // 4 bytes per pixel
    imageData.data[index + 0] = shadeOfGray * 255; // red channel
    imageData.data[index + 1] = shadeOfGray * 255; // green channel
    imageData.data[index + 2] = shadeOfGray * 255; // blue channel
    imageData.data[index + 3] = 255;
}

function setPixelRGB(xPixelIndex, yPixelIndex, r, g, b /*[0,1]*/) {
    var index = (yPixelIndex * pixelsAcross + xPixelIndex) * 4; // 4 bytes per pixel
    imageData.data[index + 0] = r; // red channel
    imageData.data[index + 1] = g; // green channel
    imageData.data[index + 2] = b; // blue channel
    imageData.data[index + 3] = 255;
}

// -----------------------------------------------------------------------------
function updateAndRender(timeElapsed) {
    var maxValue = Math.sin(Math.sqrt(2) / 4);
    var seconds = timeElapsed * 0.001; // convert milliseconds to seconds
    lightPosition.x = Math.cos(seconds) * 0.5; // radius of 0.5
    lightPosition.z = Math.sin(seconds) * 0.5; // radius of 0.5

    // Go through every pixel
    for (var yPixelIndex = 0; yPixelIndex < pixelsDown; ++yPixelIndex) {
        for (var xPixelIndex = 0; xPixelIndex < pixelsAcross; ++xPixelIndex) 
        {
            var inShadow = false;
            var pixelRay = generateRayForPixel(xPixelIndex, yPixelIndex);
            // Find the closest object seen by the pixelRay
            var closestObjectResult = null;
            var closestObject = null;
            var closestObjectDistance = null;
            for(var otherObject of scene)
            {
                objResult = otherObject.raycast(pixelRay);
                if(objResult.hit) 
                {
                    if(closestObjectResult==null || objResult.distance < closestObjectDistance)
                    {
                        closestObjectResult = objResult;
                        closestObject = otherObject;
                        closestObjectDistance = objResult.distance;
                    }
                }
            }
            if(closestObjectResult!=null)
            {
                var toLightDistanceSqr = closestObjectResult.point.minus(lightPosition).lengthSqr();
                //Make a ray from the current top-most object (aka closestObject)
                var hitToLightRay = new Ray(closestObjectResult.point,lightPosition.minus(closestObjectResult.point));
                //Check to see if any other object is between closestObjectResult.point and the light
                for(var otherObject of scene)
                {
                    if(otherObject!=closestObject) {
                        // to the light. See if 'otherObject' is between us and the light
                        var hitToOtherResult = otherObject.raycast(hitToLightRay);

                        if(hitToOtherResult.hit && toLightDistanceSqr > Math.pow(hitToOtherResult.distance,2))
                        {
                            inShadow = true;
                            break;
                        }
                    }
                }
                
                if(!inShadow)
                {
                    //Something was hit, so light the object based on the position of the light
                    var normalDotLight = closestObjectResult.normal.dot(lightPosition.minus(closestObjectResult.point).normalized());
                    setPixelColor(xPixelIndex, yPixelIndex, normalDotLight);
                }
                else
                {
                    setPixelColor(xPixelIndex, yPixelIndex,0);
                }
            }
            else 
            {
                //setPixelColor(xPixelIndex, yPixelIndex,0.1);
                setPixelRGB(xPixelIndex, yPixelIndex,0,0,128);
            }

        }
    }

    // Take our array of color data and give to the canvas to display
    canvasContext.putImageData(imageData, 0, 0);

    // Let the browser know it should call this function again when it's time to render
    requestAnimationFrame(updateAndRender);
}

// We are ready to render, let the browser know
requestAnimationFrame(updateAndRender);

</script>
</body>
</html>